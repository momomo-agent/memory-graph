<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Momo Memory Graph</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0a; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
body::before {
  content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: radial-gradient(ellipse at 50% 50%, rgba(30,30,50,0.4) 0%, rgba(10,10,10,0) 70%);
  pointer-events: none; z-index: 0;
}
svg { display: block; }
#search {
  position: fixed; top: 16px; left: 16px; z-index: 10;
  background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12);
  border-radius: 8px; padding: 8px 14px; color: #ccc; font-size: 13px;
  width: 220px; outline: none; backdrop-filter: blur(8px);
}
#search::placeholder { color: #888; }
#search:focus { border-color: rgba(255,255,255,0.3); }
#mode-switch {
  position: fixed; top: 16px; left: 250px; z-index: 10;
  background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15);
  border-radius: 8px; padding: 8px 14px; color: rgba(255,255,255,0.6);
  font-size: 13px; cursor: pointer; backdrop-filter: blur(8px);
  transition: all 0.2s ease; text-decoration: none; display: inline-block;
}
#mode-switch:hover { background: rgba(255,255,255,0.15); color: rgba(255,255,255,0.95); }
#tooltip {
  position: fixed; pointer-events: none; z-index: 20;
  background: rgba(20,20,20,0.92); border: 1px solid rgba(255,255,255,0.15);
  border-radius: 8px; padding: 10px 14px; color: #ddd; font-size: 12px;
  line-height: 1.6; backdrop-filter: blur(12px); display: none; max-width: 280px;
}
#tooltip .tt-name { font-size: 14px; font-weight: 600; margin-bottom: 4px; }
#tooltip .tt-type { color: #888; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; }
#tooltip .tt-meta { color: #999; font-size: 11px; margin-top: 4px; }
#legend {
  position: fixed; bottom: 16px; left: 16px; z-index: 10;
  background: rgba(20,20,20,0.7); border: 1px solid rgba(255,255,255,0.08);
  border-radius: 8px; padding: 0; backdrop-filter: blur(8px);
  font-size: 11px; color: #777; overflow: hidden;
  cursor: pointer; user-select: none;
}
#legend .legend-header {
  padding: 8px 14px; display: flex; align-items: center; gap: 6px;
}
#legend .legend-header::before {
  content: 'â–¶'; font-size: 8px; transition: transform 0.2s;
}
#legend.open .legend-header::before {
  transform: rotate(90deg);
}
#legend .legend-body {
  max-height: 0; overflow: hidden; transition: max-height 0.3s ease, padding 0.3s ease;
  padding: 0 14px;
}
#legend.open .legend-body {
  max-height: 400px; padding: 0 14px 10px;
}
#legend .item { display: flex; align-items: center; gap: 8px; margin: 3px 0; }
#legend .dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
#stats {
  position: fixed; top: 16px; right: 16px; z-index: 10;
  color: #777; font-size: 11px; text-align: right;
}
#controls {
  display: none;
}
#changelog {
  position: fixed; bottom: 16px; right: 16px; z-index: 10;
  width: 280px; background: rgba(15,15,15,0.85); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 10px; color: #aaa; font-size: 11px;
  backdrop-filter: blur(12px); line-height: 1.6; display: none; cursor: pointer;
}
#changelog .cl-header {
  padding: 8px 14px; display: flex; align-items: center; gap: 6px;
}
#changelog .cl-header::before {
  content: 'â–¶'; font-size: 8px; transition: transform 0.2s;
}
#changelog.open .cl-header::before {
  transform: rotate(90deg);
}
#changelog .cl-body {
  max-height: 0; overflow: hidden; transition: max-height 0.3s ease, padding 0.3s ease;
  padding: 0 14px;
}
#changelog.open .cl-body {
  max-height: 300px; padding: 0 14px 10px; overflow-y: auto;
}
@media (max-width: 600px) {
  #changelog { width: calc(100vw - 32px); left: 16px; right: auto; bottom: auto; top: 60px; font-size: 10px; }
  #changelog.open .cl-body { max-height: 200px; }
}
#changelog::-webkit-scrollbar { width: 4px; }
#changelog::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 2px; }
#changelog .cl-title { color: #666; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
#changelog .cl-entry { margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid rgba(255,255,255,0.05); }
#changelog .cl-time { color: #555; font-size: 10px; }
#changelog .cl-node { color: #6C5CE7; display: block; }
#changelog .cl-edge { color: #00D2D3; display: block; }
#changelog .cl-weight { color: #F39C12; display: block; }
#controls kbd {
  background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15);
  border-radius: 3px; padding: 1px 5px; font-family: inherit; font-size: 10px;
}
</style>
</head>
<body>
<input id="search" type="text" placeholder="æœç´¢èŠ‚ç‚¹..." autocomplete="off" spellcheck="false">
<a id="mode-switch" href="index-3d.html">åˆ‡æ¢ 3D</a>
<div id="tooltip"></div>
<div id="legend"></div>
<div id="stats"></div>
<div id="controls">
  <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> å¹³ç§»<br>
  <kbd>+</kbd><kbd>-</kbd> ç¼©æ”¾<br>
  æ»šè½®ç¼©æ”¾ Â· æ‹–æ‹½èŠ‚ç‚¹
</div>
<svg id="graph"></svg>
<div id="changelog"></div>

<script src="graph-data.js"></script>
<script>
// === DATA ===
// graphData loaded from graph-data.js
// === COLOR MAP ===
const clusterColors = {
  "design-system": "#FF4757",
  "intera-engine": "#FFC312",
  "cluster-jotjot": "#0ABDE3",
  "cluster-memory-system": "#6C5CE7",
  "bookmark-tools": "#00D2D3",
  "cluster-openclaw": "#E17055",
  "cluster-mind-palace": "#F97F51",
  "ai-native-ui": "#A55EEA",
  "cluster-agent-memory": "#FF9F1A",
  "cluster-instinct-mode": "#FF6348",
  "daily-brief-stack": "#1ABC9C",
  "cluster-hci": "#F39C12",
  "molttalk-stack": "#9B59B6",
  "cluster-webgpu": "#2ED573",
  "interaction-design": "#E84393",
  "cluster-synapse": "#FF6B81",
  "cluster-anthropic-harness": "#00CEC9",
  "toolchain": "#26DE81",
  "cluster-figma-plugin": "#A3CB38"
};
const clusterLabels = {};
const nodeCluster = {};

graphData.clusters.forEach(c => {
  clusterLabels[c.id] = c.label;
  c.nodes.forEach(nid => {
    if (!nodeCluster[nid]) nodeCluster[nid] = c.id;
  });
});

function getColor(id) {
  return clusterColors[nodeCluster[id]] || "#8395A7";
}

// === BUILD NODES & LINKS ===
const nodes = Object.entries(graphData.nodes).map(([id, meta]) => ({ id, ...meta }));
const links = graphData.edges.map(e => ({ source: e.from, target: e.to, weight: e.w }));

// degree map
const degree = {};
nodes.forEach(n => degree[n.id] = 0);
links.forEach(l => { degree[l.source] = (degree[l.source]||0) + 1; degree[l.target] = (degree[l.target]||0) + 1; });

// adjacency
const adj = {};
nodes.forEach(n => adj[n.id] = new Set());
links.forEach(l => { adj[l.source].add(l.target); adj[l.target].add(l.source); });

// === SVG SETUP ===
const W = window.innerWidth, H = window.innerHeight;
const svg = d3.select("#graph").attr("width", W).attr("height", H);
const defs = svg.append("defs");

// glow filter â€” multiple levels based on importance
[1,2,3,4,5].forEach(imp => {
  const f = defs.append("filter").attr("id", `glow${imp}`).attr("x", "-80%").attr("y", "-80%").attr("width", "260%").attr("height", "260%");
  f.append("feGaussianBlur").attr("stdDeviation", 1.5 + imp * 1.2).attr("result", "blur");
  const m = f.append("feMerge");
  m.append("feMergeNode").attr("in", "blur");
  m.append("feMergeNode").attr("in", "SourceGraphic");
});

const g = svg.append("g");

// zoom â€” trackpad: two-finger swipe = pan, pinch = zoom
const zoom = d3.zoom().scaleExtent([0.15, 5]).filter(e => {
  // Allow all non-wheel events (mouse drag, etc.)
  if (e.type !== 'wheel') return true;
  // Wheel with ctrlKey = trackpad pinch â†’ allow as zoom
  if (e.ctrlKey) return true;
  // Regular wheel (two-finger swipe) â†’ block D3 zoom, we handle it as pan below
  return false;
}).on("zoom", e => g.attr("transform", e.transform));
svg.call(zoom);

// Trackpad two-finger swipe â†’ pan
svg.node().addEventListener('wheel', e => {
  if (e.ctrlKey) return; // pinch handled by D3 zoom
  e.preventDefault();
  const t = d3.zoomTransform(svg.node());
  svg.call(zoom.transform, t.translate(-e.deltaX / t.k, -e.deltaY / t.k));
}, { passive: false });

// weight â†’ stroke width
const wScale = d3.scaleLinear().domain([1, 10]).range([0.5, 4]).clamp(true);

// degree â†’ radius
const maxDeg = d3.max(Object.values(degree)) || 1;
const rScale = d3.scaleSqrt().domain([1, maxDeg]).range([4, 22]);

// === DRAW ===
const hullG = g.append("g").attr("class", "hulls");
const linkG = g.append("g");
const pulseG = g.append("g");
const particleG = g.append("g"); // particle layer
const nodeG = g.append("g");
const labelG = g.append("g");

// Radial gradients for each node (solid core + soft edge glow)
nodes.forEach(n => {
  const c = getColor(n.id);
  const rg = defs.append("radialGradient").attr("id", `ng-${n.id.replace(/[^a-zA-Z0-9-]/g, '_')}`);
  rg.append("stop").attr("offset", "0%").attr("stop-color", c).attr("stop-opacity", 1);
  rg.append("stop").attr("offset", "70%").attr("stop-color", c).attr("stop-opacity", 0.95);
  rg.append("stop").attr("offset", "100%").attr("stop-color", c).attr("stop-opacity", 0.7);
});

// Bezier curves â€” gradient for cross-cluster edges
// First create gradient defs for each link
const linkGradients = defs.selectAll("linearGradient.link-grad")
  .data(links).join("linearGradient")
  .attr("class", "link-grad")
  .attr("id", (d, i) => `lg${i}`)
  .attr("gradientUnits", "userSpaceOnUse");

linkGradients.append("stop").attr("offset", "0%");
linkGradients.append("stop").attr("offset", "100%");

function updateGradients() {
  linkGradients
    .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
    .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
  linkGradients.select("stop:first-child")
    .attr("stop-color", d => {
      const c = getColor(d.source.id);
      const w = d.weight || 1;
      return w >= 6 ? c : d3.interpolateRgb(d3.color(c).darker(0.8), c)(Math.min(w / 6, 1));
    });
  linkGradients.select("stop:last-child")
    .attr("stop-color", d => {
      const c = getColor(d.target.id);
      const w = d.weight || 1;
      return w >= 6 ? c : d3.interpolateRgb(d3.color(c).darker(0.8), c)(Math.min(w / 6, 1));
    });
}

const linkEls = linkG.selectAll("path").data(links).join("path")
  .attr("stroke", (d, i) => `url(#lg${i})`)
  .attr("stroke-opacity", d => 0.65 + Math.min((d.weight||1) / 6, 1) * 0.35)
  .attr("stroke-width", d => wScale(d.weight))
  .attr("fill", "none")
  .style("filter", d => (d.weight || 1) >= 8 ? "url(#glow1)" : "none");

const nodeEls = nodeG.selectAll("circle").data(nodes, d => d.id).join("circle")
  .attr("r", d => rScale(degree[d.id] || 1))
  .attr("fill", d => `url(#ng-${d.id.replace(/[^a-zA-Z0-9-]/g, '_')})`)
  .attr("stroke", "none")
  .attr("fill-opacity", d => 0.9 + Math.min((degree[d.id]||1) / maxDeg, 1) * 0.1)
  .style("filter", "none")
  .style("cursor", "grab");

const labelEls = labelG.selectAll("text").data(nodes, d => d.id).join("text")
  .text(d => d.id)
  .attr("font-size", d => Math.max(8, Math.min(12, rScale(degree[d.id]||1) * 0.7)))
  .attr("fill", d => getColor(d.id)).attr("fill-opacity", d => 0.75 + Math.min((degree[d.id]||1) / maxDeg, 1) * 0.25)
  .attr("text-anchor", "middle").attr("dy", d => rScale(degree[d.id]||1) + 12)
  .style("pointer-events", "none").style("user-select", "none");

// === SIMULATION ===
// Bezier helper: slight curve offset
function linkPath(d) {
  const dx = d.target.x - d.source.x, dy = d.target.y - d.source.y;
  const dist = Math.sqrt(dx*dx + dy*dy) || 1;
  const off = dist * 0.12; // curve amount
  const mx = (d.source.x + d.target.x) / 2 - dy * off / dist;
  const my = (d.source.y + d.target.y) / 2 + dx * off / dist;
  return `M${d.source.x},${d.source.y} Q${mx},${my} ${d.target.x},${d.target.y}`;
}

// Cluster convex hulls
const clusterNodeMap = {};
graphData.clusters.forEach(c => { clusterNodeMap[c.id] = c.nodes; });

function updateHulls() {
  const hullData = [];
  Object.entries(clusterNodeMap).forEach(([cid, nids]) => {
    const pts = nids.map(nid => {
      const n = nodes.find(x => x.id === nid);
      return n ? [n.x, n.y] : null;
    }).filter(Boolean);
    if (pts.length >= 3) {
      const hull = d3.polygonHull(pts);
      if (hull) {
        // Expand hull outward with generous padding
        const cx = d3.mean(hull, p => p[0]);
        const cy = d3.mean(hull, p => p[1]);
        const padded = hull.map(p => {
          const dx = p[0] - cx, dy = p[1] - cy;
          const dist = Math.sqrt(dx*dx + dy*dy) || 1;
          return [p[0] + dx/dist * 40, p[1] + dy/dist * 40];
        });
        hullData.push({ id: cid, hull: padded });
      }
    }
  });
  const hulls = hullG.selectAll("path").data(hullData, d => d.id);
  hulls.enter().append("path")
    .attr("fill", d => clusterColors[d.id] || "#666")
    .attr("fill-opacity", 0.04)
    .attr("stroke", "none")
    .style("pointer-events", "none")
    .merge(hulls)
    .attr("d", d => {
      // Smooth catmull-rom curve through hull points
      return d3.line().curve(d3.curveCatmullRomClosed.alpha(0.5))(d.hull);
    });
  hulls.exit().remove();
}

// Breathing animation
const breathStart = Date.now();
const breathPhase = {};
nodes.forEach(n => breathPhase[n.id] = Math.random() * Math.PI * 2);

// Pulse animation state â€” now multiple particles per strong link
const particleLinks = links.filter(l => l.weight >= 6); // only strongest links
const particles = [];
particleLinks.forEach(l => {
  const count = l.weight >= 8 ? 2 : 1;
  for (let i = 0; i < count; i++) {
    particles.push({ link: l, t: Math.random(), speed: 0.002 + Math.random() * 0.002 });
  }
});

// Create particle elements â€” hidden for now
const particleEls = particleG.selectAll("circle").data(particles).join("circle")
  .attr("r", 1.5)
  .attr("fill", d => getColor(d.link.source.id || d.link.source))
  .attr("fill-opacity", 0);

// Keep old pulse dots for strongest links
const strongLinks = links.filter(l => l.weight >= 5);
const pulseProgress = {};
strongLinks.forEach((l, i) => pulseProgress[i] = Math.random());
const pulseEls = pulseG.selectAll("circle").data(strongLinks).join("circle")
  .attr("r", 1.5)
  .attr("fill", d => getColor(d.source.id || d.source))
  .attr("fill-opacity", 0);

// Initialize node positions near center to prevent drift
nodes.forEach(n => {
  n.x = W/2 + (Math.random() - 0.5) * 400;
  n.y = H/2 + (Math.random() - 0.5) * 400;
});

const sim = d3.forceSimulation(nodes)
  .force("link", d3.forceLink(links).id(d => d.id).distance(d => {
    const sd = degree[d.source.id || d.source] || 1;
    const td = degree[d.target.id || d.target] || 1;
    const hubBonus = (sd > 10 || td > 10) ? 80 : 0;
    return (160 / Math.sqrt(d.weight || 1)) + hubBonus;
  }).strength(d => {
    const sd = degree[d.source.id || d.source] || 1;
    const td = degree[d.target.id || d.target] || 1;
    const hubDamp = (sd > 10 && td > 10) ? 0.3 : 1;
    return 0.12 * Math.sqrt(d.weight || 1) * hubDamp;
  }))
  .force("charge", d3.forceManyBody().strength(d => -300 - degree[d.id] * 12).distanceMax(900))
  .force("center", d3.forceCenter(W / 2, H / 2).strength(0.01))
  .force("collision", d3.forceCollide().radius(d => rScale(degree[d.id]||1) + 24))
  .force("gravity", d3.forceRadial(0, W/2, H/2).strength(d => degree[d.id] <= 1 ? 0.04 : 0))
  // cluster attraction: same-cluster nodes pull together
  .force("cluster", d3.forceX().x(d => {
    const cid = nodeCluster[d.id];
    if (!cid) return W/2;
    const siblings = (clusterNodeMap[cid]||[]).map(nid => nodes.find(n => n.id === nid)).filter(Boolean);
    return siblings.length ? d3.mean(siblings, s => s.x || W/2) : W/2;
  }).strength(0.03))
  .force("clusterY", d3.forceY().y(d => {
    const cid = nodeCluster[d.id];
    if (!cid) return H/2;
    const siblings = (clusterNodeMap[cid]||[]).map(nid => nodes.find(n => n.id === nid)).filter(Boolean);
    return siblings.length ? d3.mean(siblings, s => s.y || H/2) : H/2;
  }).strength(0.03))
  .force("collision", d3.forceCollide().radius(d => rScale(degree[d.id]||1) + 14))
  .alphaDecay(0.02)
  .on("tick", () => {
    linkEls.attr("d", linkPath);
    nodeEls.attr("cx", d => d.x).attr("cy", d => d.y);
    labelEls.attr("x", d => d.x).attr("y", d => d.y);
    updateHulls();
    updateGradients();
  });

// === DRAG ===
nodeEls.call(d3.drag()
  .on("start", (e, d) => { if (!e.active) sim.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
  .on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; })
  .on("end", (e, d) => { if (!e.active) sim.alphaTarget(0); d.fx = null; d.fy = null; })
);

// === HOVER: NODE ===
const tooltip = d3.select("#tooltip");

nodeEls.on("mouseenter", (e, d) => {
  if (spreadActive) { // æ‰©æ•£æ¿€æ´»ä¸­ï¼Œåªæ˜¾ç¤º tooltipï¼Œä¸æ”¹é«˜äº®
    let html = `<div class="tt-name" style="color:${getColor(d.id)}">${d.id}</div>`;
    html += `<div class="tt-type">${d.type || ''}${nodeCluster[d.id] ? ' Â· ' + clusterLabels[nodeCluster[d.id]] : ''}</div>`;
    html += `<div class="tt-meta">è¿æ¥æ•°: ${degree[d.id] || 0}</div>`;
    if (d.status) html += `<div class="tt-meta">çŠ¶æ€: ${d.status}</div>`;
    if (d.relation) html += `<div class="tt-meta">å…³ç³»: ${d.relation}</div>`;
    if (d.context) html += `<div class="tt-meta">${d.context}</div>`;
    if (d.deploy) html += `<div class="tt-meta">ğŸ”— ${d.deploy}</div>`;
    tooltip.html(html).style("display", "block");
    return;
  }
  const neighbors = adj[d.id];
  nodeEls.attr("fill-opacity", n => (n.id === d.id || neighbors.has(n.id)) ? 1 : 0.08);
  linkEls.attr("stroke-opacity", l => (l.source.id === d.id || l.target.id === d.id) ? 0.9 : 0.03);
  labelEls.attr("fill-opacity", n => (n.id === d.id || neighbors.has(n.id)) ? 1 : 0.05);

  let html = `<div class="tt-name" style="color:${getColor(d.id)}">${d.id}</div>`;
  html += `<div class="tt-type">${d.type || ''}${nodeCluster[d.id] ? ' Â· ' + clusterLabels[nodeCluster[d.id]] : ''}</div>`;
  html += `<div class="tt-meta">è¿æ¥æ•°: ${degree[d.id] || 0}</div>`;
  if (d.status) html += `<div class="tt-meta">çŠ¶æ€: ${d.status}</div>`;
  if (d.relation) html += `<div class="tt-meta">å…³ç³»: ${d.relation}</div>`;
  if (d.context) html += `<div class="tt-meta">${d.context}</div>`;
  if (d.deploy) html += `<div class="tt-meta">ğŸ”— ${d.deploy}</div>`;
  tooltip.html(html).style("display", "block");
})
.on("mousemove", e => {
  tooltip.style("left", (e.clientX + 14) + "px").style("top", (e.clientY - 10) + "px");
})
.on("mouseleave", () => {
  if (!spreadActive) {
    nodeEls.attr("fill-opacity", d => 0.9 + Math.min((degree[d.id]||1) / maxDeg, 1) * 0.1);
    linkEls.attr("stroke-opacity", d => 0.65 + Math.min((d.weight||1) / 6, 1) * 0.35)
           .attr("stroke", (d, i) => `url(#lg${i})`);
    labelEls.attr("fill-opacity", d => 0.75 + Math.min((degree[d.id]||1) / maxDeg, 1) * 0.25)
            .attr("fill", d => getColor(d.id));
  }
  tooltip.style("display", "none");
});

// === SPREAD ACTIVATION (click to fire) ===
let spreadActive = false;

// Build weighted adjacency for spread
const spreadAdj = {};
Object.keys(graphData.nodes).forEach(id => { spreadAdj[id] = []; });
graphData.edges.forEach(e => {
  const ew = e.w * (e.imp || 1);
  if (!spreadAdj[e.from]) spreadAdj[e.from] = [];
  if (!spreadAdj[e.to]) spreadAdj[e.to] = [];
  spreadAdj[e.from].push({ target: e.to, w: ew });
  spreadAdj[e.to].push({ target: e.from, w: ew });
});

// Node degree for hub penalty
const vizDegree = {};
graphData.edges.forEach(e => { vizDegree[e.from] = (vizDegree[e.from]||0)+1; vizDegree[e.to] = (vizDegree[e.to]||0)+1; });
const vizMedianDeg = (() => {
  const vals = Object.values(vizDegree).sort((a,b) => a-b);
  return vals[Math.floor(vals.length/2)] || 1;
})();

function spreadActivation(seed, maxDepth=3, decay=0.5, threshold=0.1) {
  const act = {}; act[seed] = 1.0;
  const queue = [{ id: seed, energy: 1.0, depth: 0 }];
  while (queue.length) {
    const { id, energy, depth } = queue.shift();
    if (depth >= maxDepth) continue;
    const nb = spreadAdj[id] || [];
    const maxW = Math.max(...nb.map(n => n.w), 1);
    for (const n of nb) {
      const targetDeg = vizDegree[n.target] || 1;
      const hubPenalty = targetDeg > vizMedianDeg * 2 ? vizMedianDeg / targetDeg : 1.0;
      const t = energy * (n.w / maxW) * decay * hubPenalty;
      if (t < 0.005) continue;
      act[n.target] = (act[n.target] || 0) + t;
      if (t >= threshold * 0.3) queue.push({ id: n.target, energy: t, depth: depth + 1 });
    }
  }
  return act;
}

// Animated spread on click â€” wave propagation along edges
nodeEls.on("click", (e, d) => {
  e.stopPropagation();
  spreadActive = true;
  const act = spreadActivation(d.id);
  const maxAct = Math.max(...Object.values(act));

  // BFS to get depth (hop count) from seed for wave timing
  const depth = {}; depth[d.id] = 0;
  const bfsQueue = [d.id];
  const visited = new Set([d.id]);
  while (bfsQueue.length) {
    const cur = bfsQueue.shift();
    const nb = adj[cur] || new Set();
    nb.forEach(nid => {
      if (!visited.has(nid) && act[nid]) {
        visited.add(nid);
        depth[nid] = depth[cur] + 1;
        bfsQueue.push(nid);
      }
    });
  }
  const maxDepth = Math.max(...Object.values(depth), 1);
  const waveMs = 600; // ms per hop

  // Dim everything first
  nodeEls.transition("spread-dim").duration(200).attr("fill-opacity", 0.03);
  linkEls.transition("spread-dim").duration(200).attr("stroke-opacity", 0.02);
  labelEls.transition("spread-dim").duration(200).attr("fill-opacity", 0.03);

  // Wave: light up nodes by depth â€” same opacity as default state
  Object.entries(act).forEach(([nid, energy]) => {
    const hop = depth[nid] || 0;
    const delay = 250 + hop * waveMs;
    const defaultNodeOp = 0.9 + Math.min((degree[nid]||1) / maxDeg, 1) * 0.1;
    const defaultLabelOp = 0.75 + Math.min((degree[nid]||1) / maxDeg, 1) * 0.25;
    nodeEls.filter(n => n.id === nid)
      .transition("spread-light").delay(delay).duration(350)
      .attr("fill-opacity", defaultNodeOp);
    labelEls.filter(n => n.id === nid)
      .transition("spread-light").delay(delay).duration(350)
      .attr("fill-opacity", defaultLabelOp)
      .attr("fill", getColor(nid));
  });

  // Wave: light up edges â€” same opacity as default state
  const actSet = new Set(Object.keys(act));
  linkEls.filter(l => actSet.has(l.source.id) && actSet.has(l.target.id))
    .each(function(l) {
      const srcDepth = depth[l.source.id] || 0;
      const tgtDepth = depth[l.target.id] || 0;
      const edgeHop = Math.min(srcDepth, tgtDepth);
      const delay = 250 + edgeHop * waveMs + waveMs * 0.3;
      const defaultLinkOp = 0.65 + Math.min((l.weight||1) / 6, 1) * 0.35;
      d3.select(this).transition("spread-light").delay(delay).duration(350)
        .attr("stroke-opacity", defaultLinkOp);
    });
});

// Click background to reset
svg.on("click", () => {
  if (!spreadActive) return;
  spreadActive = false;
  nodeEls.transition().duration(400)
    .attr("fill-opacity", d => 0.78 + Math.min((degree[d.id]||1) / maxDeg, 1) * 0.22);
  linkEls.transition().duration(400)
    .attr("stroke-opacity", d => 0.45 + Math.min((d.weight||1) / 8, 1) * 0.5)
    .attr("stroke", (d, i) => `url(#lg${i})`);
  labelEls.transition().duration(400)
    .attr("fill-opacity", d => 0.6 + Math.min((degree[d.id]||1) / maxDeg, 1) * 0.4).attr("fill", d => getColor(d.id));
  particleEls.transition().duration(400)
    .attr("fill-opacity", 0.6);
});

// === HOVER: EDGE ===
linkEls.on("mouseenter", (e, d) => {
  tooltip.html(`<div class="tt-name">${d.source.id} â†” ${d.target.id}</div><div class="tt-meta">weight: ${d.weight}</div>`)
         .style("display", "block");
})
.on("mousemove", e => {
  tooltip.style("left", (e.clientX + 14) + "px").style("top", (e.clientY - 10) + "px");
})
.on("mouseleave", () => { tooltip.style("display", "none"); });

// === SEARCH ===
const searchInput = document.getElementById("search");
searchInput.addEventListener("input", () => {
  const q = searchInput.value.trim().toLowerCase();
  if (!q) {
    nodeEls.attr("fill-opacity", 0.85).attr("stroke-opacity", 0.5).attr("stroke-width", 1.5);
    linkEls.attr("stroke-opacity", 0.4);
    labelEls.attr("fill-opacity", 0.7);
    return;
  }
  const matched = new Set();
  nodes.forEach(n => { if (n.id.toLowerCase().includes(q)) matched.add(n.id); });
  nodeEls.attr("fill-opacity", n => matched.has(n.id) ? 1 : 0.08)
         .attr("stroke-opacity", n => matched.has(n.id) ? 1 : 0.05)
         .attr("stroke-width", n => matched.has(n.id) ? 3 : 1.5);
  linkEls.attr("stroke-opacity", l => (matched.has(l.source.id) || matched.has(l.target.id)) ? 0.6 : 0.03);
  labelEls.attr("fill-opacity", n => matched.has(n.id) ? 1 : 0.05);
});

// === LEGEND ===
const legendDiv = document.getElementById("legend");
const legendItems = graphData.clusters.map(c => [c.label, clusterColors[c.id] || "#888"]);
legendItems.push(["æ— é›†ç¾¤", "#dddddd"]);
legendDiv.innerHTML = '<div class="legend-header">å›¾ä¾‹</div><div class="legend-body">' + legendItems.map(([l, c]) =>
  `<div class="item"><div class="dot" style="background:${c};box-shadow:0 0 6px ${c}"></div>${l}</div>`
).join("") + '</div>';
legendDiv.addEventListener('click', () => legendDiv.classList.toggle('open'));

// === STATS ===
document.getElementById("stats").textContent = `${nodes.length} nodes Â· ${links.length} edges`;

// === RESIZE ===
window.addEventListener("resize", () => {
  const w = window.innerWidth, h = window.innerHeight;
  svg.attr("width", w).attr("height", h);
  sim.force("center", d3.forceCenter(w / 2, h / 2))
     .alpha(0.1).restart();
});

// === BREATHING + PARTICLE FLOW ANIMATION ===
function quadBezierPoint(sx, sy, mx, my, tx, ty, t) {
  const x = (1-t)*(1-t)*sx + 2*(1-t)*t*mx + t*t*tx;
  const y = (1-t)*(1-t)*sy + 2*(1-t)*t*my + t*t*ty;
  return [x, y];
}

function animateLoop() {
  const t = (Date.now() - breathStart) / 1000;
  // Breathing: subtle radius oscillation
  nodeEls.attr("r", d => {
    const base = rScale(degree[d.id] || 1);
    const breath = Math.sin(t * 0.8 + breathPhase[d.id]) * base * 0.04;
    return base + breath;
  });

  // Particle flow along edges
  particles.forEach((p, i) => {
    p.t += p.speed;
    if (p.t > 1) p.t -= 1;
    const l = p.link;
    const sx = l.source.x, sy = l.source.y, tx = l.target.x, ty = l.target.y;
    const dx = tx - sx, dy = ty - sy;
    const dist = Math.sqrt(dx*dx + dy*dy) || 1;
    const off = dist * 0.12;
    const mx = (sx + tx) / 2 - dy * off / dist;
    const my = (sy + ty) / 2 + dx * off / dist;
    const [px, py] = quadBezierPoint(sx, sy, mx, my, tx, ty, p.t);
    // Fade in/out at endpoints
    const fade = Math.min(p.t * 5, (1 - p.t) * 5, 1);
    const el = d3.select(particleEls.nodes()[i]);
    el.attr("cx", px).attr("cy", py).attr("fill-opacity", 0.5 * fade);
  });

  // Old pulse dots â€” keep them too for strongest links
  strongLinks.forEach((l, i) => {
    pulseProgress[i] += 0.003 * (l.weight / 5);
    if (pulseProgress[i] > 1) pulseProgress[i] = 0;
    const p = pulseProgress[i];
    const sx = l.source.x, sy = l.source.y, tx = l.target.x, ty = l.target.y;
    const dx = tx - sx, dy = ty - sy;
    const dist = Math.sqrt(dx*dx + dy*dy) || 1;
    const off = dist * 0.12;
    const mx = (sx + tx) / 2 - dy * off / dist;
    const my = (sy + ty) / 2 + dx * off / dist;
    const [px, py] = quadBezierPoint(sx, sy, mx, my, tx, ty, p);
    d3.select(pulseEls.nodes()[i]).attr("cx", px).attr("cy", py);
  });

  requestAnimationFrame(animateLoop);
}
requestAnimationFrame(animateLoop);

// === WASD + -/= NAVIGATION ===
const PAN_SPEED = 40;
const ZOOM_STEP = 0.15;
const keys = {};

window.addEventListener("keydown", e => {
  if (e.target === searchInput) return; // æœç´¢æ¡†é‡Œä¸è§¦å‘
  keys[e.key.toLowerCase()] = true;
});
window.addEventListener("keyup", e => {
  keys[e.key.toLowerCase()] = false;
});

function navTick() {
  let dx = 0, dy = 0, dz = 0;
  if (keys['w'] || keys['arrowup']) dy += PAN_SPEED;
  if (keys['s'] || keys['arrowdown']) dy -= PAN_SPEED;
  if (keys['a'] || keys['arrowleft']) dx += PAN_SPEED;
  if (keys['d'] || keys['arrowright']) dx -= PAN_SPEED;
  if (keys['='] || keys['+']) dz = ZOOM_STEP;
  if (keys['-']) dz = -ZOOM_STEP;

  if (dx || dy || dz) {
    const t = d3.zoomTransform(svg.node());
    if (dz) {
      const newK = Math.max(0.15, Math.min(5, t.k * (1 + dz)));
      const cx = window.innerWidth / 2, cy = window.innerHeight / 2;
      svg.call(zoom.transform, d3.zoomIdentity
        .translate(cx, cy)
        .scale(newK)
        .translate(-(cx - t.x) / t.k, -(cy - t.y) / t.k));
    } else {
      svg.call(zoom.transform, t.translate(dx / t.k, dy / t.k));
    }
  }
  requestAnimationFrame(navTick);
}
requestAnimationFrame(navTick);

// === CHANGELOG ===
if (typeof graphChangelog !== 'undefined' && graphChangelog.length) {
  const el = document.getElementById('changelog');
  let body = '';
  graphChangelog.slice().reverse().forEach(e => {
    const t = new Date(e.ts);
    const time = `${t.getMonth()+1}/${t.getDate()} ${String(t.getHours()).padStart(2,'0')}:${String(t.getMinutes()).padStart(2,'0')}`;
    let parts = [];
    if (e.nodes?.length) parts.push(e.nodes.map(n => `<span class="cl-node">+${n}</span>`).join(' '));
    if (e.edges?.length) parts.push(e.edges.map(x => `<span class="cl-edge">${x}</span>`).join(' '));
    if (e.weights?.length) parts.push(e.weights.map(w => `<span class="cl-weight">${w.edge} ${w.from.toFixed(2)}â†’${w.to.toFixed(2)}</span>`).join(' '));
    if (parts.length) body += `<div class="cl-entry"><span class="cl-time">${time}</span> ${parts.join(' ')}</div>`;
  });
  if (body) {
    el.innerHTML = `<div class="cl-header">å˜åŒ–è®°å½•</div><div class="cl-body">${body}</div>`;
    el.style.display = 'block';
    el.querySelector('.cl-header').addEventListener('click', () => el.classList.toggle('open'));
  }
}
</script>
</body>
</html>
