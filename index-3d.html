<!DOCTYPE html>
<html lang="zh-CN">
<head>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üß†</text></svg>">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Momo Memory Graph ‚Äî 3D</title>
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<!-- postprocessing disabled: CDN 404, emissive glow works without bloom
<script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/shaders/FXAAShader.js"></script>
-->
<script src="https://unpkg.com/three-spritetext@1.8.2/dist/three-spritetext.min.js"></script>
<script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0f; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
#search {
  background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12);
  border-radius: 6px; padding: 7px 12px; color: #ccc; font-size: 13px;
  width: 180px; outline: none; backdrop-filter: blur(8px);
}
#search::placeholder { color: #888; }
#search:focus { border-color: rgba(255,255,255,0.3); }
#mode-switch, #layout-toggle {
  background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15);
  border-radius: 6px; padding: 7px 12px; color: rgba(255,255,255,0.6);
  font-size: 13px; cursor: pointer; backdrop-filter: blur(8px);
  transition: all 0.2s ease; text-decoration: none; white-space: nowrap;
}
#mode-switch:hover, #layout-toggle:hover { background: rgba(255,255,255,0.15); color: rgba(255,255,255,0.95); }
#top-bar {
  position: fixed; top: 12px; left: 12px; z-index: 100;
  display: flex; gap: 8px; align-items: center;
}
#tooltip {
  position: fixed; pointer-events: none; z-index: 20;
  background: rgba(20,20,20,0.92); border: 1px solid rgba(255,255,255,0.15);
  border-radius: 8px; padding: 10px 14px; color: #ddd; font-size: 12px;
  line-height: 1.6; backdrop-filter: blur(12px); display: none; max-width: 280px;
}
#tooltip .tt-name { font-size: 14px; font-weight: 600; margin-bottom: 4px; }
#tooltip .tt-type { color: #888; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; }
#tooltip .tt-meta { color: #999; font-size: 11px; margin-top: 4px; }
#legend {
  position: fixed; bottom: 16px; left: 16px; z-index: 10;
  background: rgba(20,20,20,0.7); border: 1px solid rgba(255,255,255,0.08);
  border-radius: 8px; padding: 0; backdrop-filter: blur(8px);
  font-size: 11px; color: #777; overflow: hidden;
  cursor: pointer; user-select: none;
}
#legend .legend-header {
  padding: 8px 14px; display: flex; align-items: center; gap: 6px;
}
#legend .legend-header::before {
  content: '‚ñ∂'; font-size: 8px; transition: transform 0.2s;
}
#legend.open .legend-header::before {
  transform: rotate(90deg);
}
#legend .legend-body {
  max-height: 0; overflow: hidden; transition: max-height 0.3s ease, padding 0.3s ease;
  padding: 0 14px;
}
#legend.open .legend-body {
  max-height: 400px; padding: 0 14px 10px;
}
#legend .item { display: flex; align-items: center; gap: 8px; margin: 3px 0; }
#legend .dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
#stats {
  position: fixed; top: 16px; right: 16px; z-index: 10;
  color: #777; font-size: 11px; text-align: right;
}
#controls {
  display: none;
}
#link-tooltip {
  position: fixed; pointer-events: none; z-index: 20;
  background: rgba(20,20,20,0.92); border: 1px solid rgba(255,255,255,0.15);
  border-radius: 8px; padding: 8px 12px; color: #ddd; font-size: 12px;
  line-height: 1.5; backdrop-filter: blur(12px); display: none;
}
#graph-container { width: 100vw; height: 100vh; }
#changelog {
  position: fixed; bottom: 16px; right: 16px; z-index: 10;
  width: 280px; background: rgba(15,15,15,0.85); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 10px; padding: 0; backdrop-filter: blur(12px);
  font-size: 11px; color: #aaa; line-height: 1.6; overflow: hidden;
  cursor: pointer; user-select: none; display: none;
}
#changelog .cl-header {
  padding: 8px 14px; display: flex; align-items: center; gap: 6px;
}
#changelog .cl-header::before {
  content: '‚ñ∂'; font-size: 8px; transition: transform 0.2s;
}
#changelog.open .cl-header::before {
  transform: rotate(90deg);
}
#changelog .cl-body {
  max-height: 0; overflow: hidden; transition: max-height 0.3s ease, padding 0.3s ease;
  padding: 0 14px;
}
#changelog.open .cl-body {
  max-height: 300px; padding: 0 14px 10px; overflow-y: auto;
}
@media (max-width: 600px) {
  #changelog { width: auto; max-width: 45vw; right: 12px; bottom: 12px; font-size: 10px; }
  #changelog.open { max-width: calc(100vw - 32px); width: calc(100vw - 32px); }
  #changelog.open .cl-body { max-height: 200px; }
}
#changelog::-webkit-scrollbar { width: 4px; }
#changelog::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 2px; }
#changelog .cl-title { color: #666; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
#changelog .cl-entry { margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid rgba(255,255,255,0.05); }
#changelog .cl-time { color: #555; font-size: 10px; }
#changelog .cl-node { color: #6C5CE7; display: block; }
#changelog .cl-edge { color: #00D2D3; display: block; }
#changelog .cl-weight { color: #F39C12; display: block; }
</style>
</head>
<body>
<div id="top-bar">
<input id="search" type="text" placeholder="ÊêúÁ¥¢ËäÇÁÇπ..." autocomplete="off" spellcheck="false">
<a id="mode-switch" href="index-2d.html">ÂàáÊç¢ 2D</a>
<a id="layout-toggle">ËØ≠‰πâÂ∏ÉÂ±Ä</a>
</div>
<div id="tooltip"></div>
<div id="legend"></div>
<div id="stats"></div>
<div id="controls">Èº†Ê†áÊãñÊãΩÊóãËΩ¨ ¬∑ ÊªöËΩÆÂâçËøõÂêéÈÄÄ ¬∑ WASDÁ©øÊ¢≠ ¬∑ ÁÇπÂáªËäÇÁÇπÊâ©Êï£ ¬∑ ÁÇπÂáªÁ©∫ÁôΩ/ESCÊÅ¢Â§ç</div>
<div id="link-tooltip"></div>
<div id="graph-container"></div>
<div id="changelog"></div>

<script src="graph-data.js?v=1772273231"></script>
<script>
// === DATA ===
let semanticMode = false;
// graphData loaded from graph-data.js
// Dynamic cluster colors ‚Äî HSL color wheel, evenly spaced
const clusterIds = (graphData.clusters || []).map(c => c.id);
const clusterColors = {};
clusterIds.forEach((id, i) => {
  const hue = (i * 360 / Math.max(clusterIds.length, 1) + 15) % 360; // offset 15¬∞ to avoid pure red at 0
  const sat = 65 + (i % 3) * 10; // vary saturation 65-85%
  const lit = 55 + (i % 2) * 10; // vary lightness 55-65%
  clusterColors[id] = `hsl(${hue}, ${sat}%, ${lit}%)`;
});

// === DERIVED DATA ===
const clusterLabels = {};
const nodeCluster = {};
(graphData.clusters || []).forEach(c => {
  clusterLabels[c.id] = c.label;
  c.nodes.forEach(nid => { if (!nodeCluster[nid]) nodeCluster[nid] = c.id; });
});

function getColor(id) {
  return clusterColors[nodeCluster[id]] || "#8395A7";
}

// Build nodes & links for 3d-force-graph
const nodes = Object.entries(graphData.nodes).map(([id, meta]) => ({ id, ...meta }));
const links = graphData.edges.map(e => ({ source: e.from, target: e.to, weight: e.w }));

// Degree map
const degree = {};
nodes.forEach(n => degree[n.id] = 0);
links.forEach(l => { degree[l.source] = (degree[l.source]||0) + 1; degree[l.target] = (degree[l.target]||0) + 1; });
const maxDeg = Math.max(...Object.values(degree), 1);

// Adjacency
const adj = {};
nodes.forEach(n => adj[n.id] = new Set());
links.forEach(l => { if (adj[l.source] && adj[l.target]) { adj[l.source].add(l.target); adj[l.target].add(l.source); } });

// Cluster node map
const clusterNodeMap = {};
(graphData.clusters || []).forEach(c => { clusterNodeMap[c.id] = c.nodes; });

// === SPREAD ACTIVATION DATA ===
const spreadAdj = {};
graphData.edges.forEach(e => {
  const ew = e.w * (e.imp || 1);
  if (!spreadAdj[e.from]) spreadAdj[e.from] = [];
  if (!spreadAdj[e.to]) spreadAdj[e.to] = [];
  spreadAdj[e.from].push({ target: e.to, w: ew });
  spreadAdj[e.to].push({ target: e.from, w: ew });
});
const vizDegree = degree;
const degValues = Object.values(vizDegree).sort((a,b) => a - b);
const vizMedianDeg = degValues[Math.floor(degValues.length / 2)] || 1;

function spreadActivation(seed, maxDepth=3, decay=0.5, threshold=0.1) {
  const act = {}; act[seed] = 1.0;
  const queue = [{ id: seed, energy: 1.0, depth: 0 }];
  while (queue.length) {
    const { id, energy, depth } = queue.shift();
    if (depth >= maxDepth) continue;
    const nb = spreadAdj[id] || [];
    const maxW = Math.max(...nb.map(n => n.w), 1);
    for (const n of nb) {
      const targetDeg = vizDegree[n.target] || 1;
      const hubPenalty = targetDeg > vizMedianDeg * 2 ? vizMedianDeg / targetDeg : 1.0;
      const t = energy * (n.w / maxW) * decay * hubPenalty;
      if (t < 0.005) continue;
      act[n.target] = (act[n.target] || 0) + t;
      if (t >= threshold * 0.3) queue.push({ id: n.target, energy: t, depth: depth + 1 });
    }
  }
  return act;
}

// Color blending helper
function blendColors(c1, c2) {
  const a = new THREE.Color(c1), b = new THREE.Color(c2);
  return new THREE.Color((a.r+b.r)/2, (a.g+b.g)/2, (a.b+b.b)/2);
}

// Breathing phase per node
nodes.forEach(n => { n.__breathPhase = Math.random() * Math.PI * 2; });

// Spread activation state
let spreadActive = false;
const litNodes = new Set(); // nodes lit by spread activation
const litLinks = new Set(); // link indices lit by spread activation
let spreadTimeouts = [];

// Particle flow data for strong links
const flowParticles = [];

// === 3D FORCE GRAPH ===
const container = document.getElementById('graph-container');
let hoveredNode = null;
let clickedNode = null;

const Graph = ForceGraph3D()(container)
  .backgroundColor('#0a0a0f')
  .graphData({ nodes, links })
  // Today's active set
  ;const _activeNodes3d = new Set((typeof todayActive !== 'undefined' ? todayActive.nodes : []));
  const _activeEdges3d = new Set((typeof todayActive !== 'undefined' ? todayActive.edges : []));
  Graph
  // Node appearance
  .nodeThreeObject(node => {
    const color = getColor(node.id);
    const deg = degree[node.id] || 1;
    const radius = 1.5 + Math.sqrt(deg / maxDeg) * 5;

    // Group to hold sphere + label + hitbox
    const group = new THREE.Group();

    // Sphere
    const geometry = new THREE.SphereGeometry(radius, 16, 12);
    const material = new THREE.MeshPhongMaterial({
      color: new THREE.Color(color),
      emissive: new THREE.Color(color),
      emissiveIntensity: 0.3,
      transparent: true,
      opacity: 0.85,
      shininess: 30
    });
    const sphere = new THREE.Mesh(geometry, material);
    group.add(sphere);

    // Invisible hitbox ‚Äî slightly larger for hover/click detection
    const hitGeo = new THREE.SphereGeometry(radius * 1.2, 8, 6);
    const hitMat = new THREE.MeshBasicMaterial({ visible: false });
    const hitbox = new THREE.Mesh(hitGeo, hitMat);
    group.add(hitbox);

    // Label sprite
    const enAlias = (node.aliases || []).find(a => /^[a-zA-Z]/.test(a) && a !== node.id.replace(/-/g, ' '));
    const sprite = new SpriteText(enAlias || node.id);
    sprite.color = color;
    sprite.textHeight = Math.max(3, Math.min(6, radius * 0.8));
    sprite.position.y = -(radius + 2);
    sprite.fontFace = '-apple-system, BlinkMacSystemFont, sans-serif';
    sprite.material.depthWrite = false;
    sprite.material.transparent = true;
    sprite.material.opacity = 0.85;
    group.add(sprite);

    // Store refs for hover/click
    node.__sphere = sphere;
    node.__label = sprite;
    node.__radius = radius;
    node.__color = color;
    node.__active = _activeNodes3d.has(node.id);

    return group;
  })
  .nodeThreeObjectExtend(false)
  // Link appearance ‚Äî built-in curved links with blended colors
  .linkCurvature(0.25)
  .linkCurveRotation(link => {
    const srcId = typeof link.source === 'object' ? link.source.id : link.source;
    const tgtId = typeof link.target === 'object' ? link.target.id : link.target;
    return (srcId + tgtId).split('').reduce((a, c) => a + c.charCodeAt(0), 0) % 628 / 100;
  })
  .linkMaterial(link => {
    // Cache material on the link object so library reuses the same ref each frame.
    // We'll pulse opacity + emissive later for today's active links.
    if (!link.__customMat) {
      const srcId = typeof link.source === 'object' ? link.source.id : link.source;
      const tgtId = typeof link.target === 'object' ? link.target.id : link.target;
      const c1 = new THREE.Color(getColor(srcId));
      const c2 = new THREE.Color(getColor(tgtId));
      c1.lerp(c2, 0.5);
      const w = link.weight || 1;
      const opacity = semanticMode 
        ? (w >= 2.5 ? 0.03 + Math.min(w / 10, 1) * 0.15 : 0)
        : (0.03 + Math.min(w / 10, 1) * 0.25);
      link.__customMat = new THREE.LineBasicMaterial({
        color: semanticMode ? new THREE.Color('#445566') : c1,
        transparent: true,
        opacity,
        depthWrite: false,
        blending: semanticMode ? THREE.NormalBlending : THREE.AdditiveBlending
      });
    }
    return link.__customMat;
  })
  .linkWidth(link => {
    const w = link.weight || 1;
    return 0.1 + Math.min(w / 10, 1) * 0.9;
  })
  // Force layout tuning
  .d3AlphaDecay(0.02)
  .d3VelocityDecay(0.3)
  // Node hover
  .onNodeHover(node => {
    container.style.cursor = node ? 'pointer' : 'default';
    hoveredNode = node;
    if (!spreadActive) updateHighlight();
    if (node) {
      showTooltip(node);
    } else {
      document.getElementById('tooltip').style.display = 'none';
    }
  })
  // Link hover tooltip
  .onLinkHover(link => {
    const lt = document.getElementById('link-tooltip');
    if (link) {
      const srcId = typeof link.source === 'object' ? link.source.id : link.source;
      const tgtId = typeof link.target === 'object' ? link.target.id : link.target;
      lt.innerHTML = srcId + ' ‚Üî ' + tgtId + '<br>weight: ' + (link.weight || 1);
      lt.style.display = 'block';
    } else {
      lt.style.display = 'none';
    }
  })
  // Drag ‚Äî update cluster auras in real-time
  .onNodeDrag(() => { updateClusterAuras(); })
  .onNodeDragEnd(() => { updateClusterAuras(); })
  // Click ‚Äî spread activation
  .onNodeClick(node => {
    if (spreadActive && clickedNode === node) {
      // Clicking same node again ‚Äî restore all (animated)
      restoreAll();
      return;
    }
    // New node ‚Äî reset previous spread instantly, then start fresh
    restoreAll(true);
    clickedNode = node;
    triggerSpreadActivation(node);
    showTooltip(node);
  })
  .onBackgroundClick(() => { restoreAll(); });

window._Graph = Graph; // expose for debugging

// === SEMANTIC LAYOUT TOGGLE ===
const layoutBtn = document.getElementById('layout-toggle');
let _savedForcePositions = {};

layoutBtn.addEventListener('click', () => {
  if (!embPositions) { layoutBtn.textContent = 'Êó†ËØ≠‰πâÊï∞ÊçÆ'; return; }
  semanticMode = !semanticMode;
  layoutBtn.textContent = semanticMode ? 'ÂäõÂØºÂêëÂ∏ÉÂ±Ä' : 'ËØ≠‰πâÂ∏ÉÂ±Ä';
  layoutBtn.style.color = semanticMode ? '#6cf' : '#aaa';
  Graph.graphData().links.forEach(l => { delete l.__customMat; });
  
  if (semanticMode) {
    nodes.forEach(n => { _savedForcePositions[n.id] = { x: n.x, y: n.y, z: n.z }; });
    // Zero out forces (don't delete them)
    const cf = Graph.d3Force('charge'); if (cf) cf.strength(0);
    const lf = Graph.d3Force('link'); if (lf) lf.strength(0);
    const cef = Graph.d3Force('center'); if (cef && cef.strength) cef.strength(0);
    animateToPositions(embPositions, 1200, () => {
      Graph.cameraPosition({ x: 0, y: 0, z: 1200 }, { x: 0, y: 0, z: 0 }, 800);
    });
  } else {
    animateToPositions(_savedForcePositions, 1200, () => {
      nodes.forEach(n => { delete n.fx; delete n.fy; delete n.fz; });
      // Restore original force strengths
      const cf = Graph.d3Force('charge');
      if (cf) cf.strength(d => -30 - (degree[d.id] || 0) * 3).distanceMax(300);
      const lf = Graph.d3Force('link');
      if (lf) {
        lf.distance(d => {
          const sd = degree[typeof d.source === 'object' ? d.source.id : d.source] || 1;
          const td = degree[typeof d.target === 'object' ? d.target.id : d.target] || 1;
          return 30 + 60 / Math.sqrt(d.weight || 1) + ((sd > 10 || td > 10) ? 20 : 0);
        }).strength(d => 0.15 * Math.sqrt(d.weight || 1));
      }
      const cef = Graph.d3Force('center');
      if (cef && cef.strength) cef.strength(0.05);
      Graph.d3ReheatSimulation();
    });
  }
});

function animateToPositions(targetMap, durationMs, onDone) {
  const starts = {};
  nodes.forEach(n => { starts[n.id] = { x: n.x || 0, y: n.y || 0, z: n.z || 0 }; });
  const t0 = performance.now();
  (function step() {
    const t = Math.min((performance.now() - t0) / durationMs, 1);
    const ease = t < 0.5 ? 2*t*t : -1+(4-2*t)*t; // ease in-out quad
    nodes.forEach(n => {
      const target = targetMap[n.id];
      if (!target) return;
      const s = starts[n.id];
      const tx = target.fx !== undefined ? target.fx : target.x;
      const ty = target.fy !== undefined ? target.fy : target.y;
      const tz = target.fz !== undefined ? target.fz : target.z;
      n.x = s.x + (tx - s.x) * ease;
      n.y = s.y + (ty - s.y) * ease;
      n.z = s.z + (tz - s.z) * ease;
      if (semanticMode) { n.fx = n.x; n.fy = n.y; n.fz = n.z; }
    });
    Graph.graphData().nodes = nodes; // trigger re-render
    Graph.refresh();
    if (t < 1) requestAnimationFrame(step);
    else if (onDone) onDone();
  })();
}

// Disable OrbitControls default zoom/pan ‚Äî we handle it ourselves
setTimeout(() => {
  const controls = Graph.controls();
  if (controls) {
    controls.enableZoom = false;
    controls.enablePan = false;
  }
}, 100);

// Configure forces via the graph's internal d3 engine
// Customize charge force
const chargeForce = Graph.d3Force('charge');
if (chargeForce) {
  chargeForce.strength(d => -30 - (degree[d.id] || 0) * 3).distanceMax(300);
}
// Customize link force
const linkForce = Graph.d3Force('link');
if (linkForce) {
  linkForce.distance(d => {
    const sd = degree[typeof d.source === 'object' ? d.source.id : d.source] || 1;
    const td = degree[typeof d.target === 'object' ? d.target.id : d.target] || 1;
    return 30 + 60 / Math.sqrt(d.weight || 1) + ((sd > 10 || td > 10) ? 20 : 0);
  }).strength(d => 0.15 * Math.sqrt(d.weight || 1));
}
// Customize center force
const centerForce = Graph.d3Force('center');
if (centerForce && centerForce.strength) {
  centerForce.strength(0.05);
}

// Add d3 force for clustering
Graph.d3Force('cluster', alpha => {
  nodes.forEach(node => {
    const cid = nodeCluster[node.id];
    if (!cid) return;
    const siblings = (clusterNodeMap[cid] || [])
      .map(nid => nodes.find(n => n.id === nid))
      .filter(n => n && n.x !== undefined);
    if (siblings.length < 2) return;
    const cx = siblings.reduce((s, n) => s + (n.x || 0), 0) / siblings.length;
    const cy = siblings.reduce((s, n) => s + (n.y || 0), 0) / siblings.length;
    const cz = siblings.reduce((s, n) => s + (n.z || 0), 0) / siblings.length;
    const k = alpha * 0.15;
    node.vx += (cx - node.x) * k;
    node.vy += (cy - node.y) * k;
    node.vz += (cz - node.z) * k;
  });
});

// === HIGHLIGHT (hover only, when spread not active) ===
function updateHighlight() {
  if (spreadActive) return;
  const focusNode = hoveredNode;

  if (!focusNode) {
    // No hover ‚Äî restore all to default
    nodes.forEach(node => {
      if (!node.__sphere) return;
      node.__sphere.material.opacity = 0.85;
      node.__sphere.material.emissiveIntensity = 0.3;
      if (node.__label) node.__label.material.opacity = 0.85;
    });
    const gData = Graph.graphData();
    gData.links.forEach(link => {
      if (link.__customMat) link.__customMat.opacity = 0.1 + Math.min((link.weight||1)/8,1)*0.7;
    });
    return;
  }

  // Use spread activation for hover ‚Äî same visual as click
  const act = spreadActivation(focusNode.id);
  const maxAct = Math.max(...Object.values(act));
  const actSet = new Set(Object.keys(act));

  // Dim non-activated, light up activated (same as click behavior)
  nodes.forEach(node => {
    if (!node.__sphere) return;
    const mat = node.__sphere.material;
    const label = node.__label;
    if (node.id === focusNode.id) {
      mat.opacity = 1.0;
      mat.emissiveIntensity = 1.0;
      if (label) label.material.opacity = 1.0;
    } else if (actSet.has(node.id)) {
      const energy = (act[node.id] || 0) / maxAct;
      mat.opacity = 0.3 + energy * 0.7;
      mat.emissiveIntensity = 0.2 + energy * 0.6;
      if (label) label.material.opacity = 0.3 + energy * 0.7;
    } else {
      mat.opacity = 0.08;
      mat.emissiveIntensity = 0.05;
      if (label) label.material.opacity = 0.05;
    }
  });

  const gData = Graph.graphData();
  gData.links.forEach(link => {
    if (!link.__customMat) return;
    const srcId = typeof link.source === 'object' ? link.source.id : link.source;
    const tgtId = typeof link.target === 'object' ? link.target.id : link.target;
    if (actSet.has(srcId) && actSet.has(tgtId)) {
      const e = Math.min((act[srcId] || 0), (act[tgtId] || 0)) / maxAct;
      link.__customMat.opacity = 0.3 + e * 0.7;
    } else {
      link.__customMat.opacity = 0.02;
    }
  });
}

// === SPREAD ACTIVATION (neural pulse propagation) ===
// Pulse particles that travel along edges like neural signals
const pulseParticles = [];
let pulseAnimRunning = false;

function triggerSpreadActivation(node) {
  spreadActive = true;
  spreadTimeouts.forEach(t => clearTimeout(t));
  spreadTimeouts = [];
  // Clean up old pulse particles
  pulseParticles.forEach(p => { if (p.currentLine) Graph.scene().remove(p.currentLine); });
  pulseParticles.length = 0;

  const act = spreadActivation(node.id);
  const maxAct = Math.max(...Object.values(act));

  // BFS depth from seed ‚Äî use spreadAdj (weighted) for correct path selection
  // Only include nodes that spreadActivation actually activated
  const depthMap = {}; depthMap[node.id] = 0;
  const bfsQueue = [node.id];
  const visited = new Set([node.id]);
  const parentMap = {}; // track BFS tree for directed current
  while (bfsQueue.length) {
    const cur = bfsQueue.shift();
    // Sort neighbors by activation energy (strongest first) for better path selection
    const nb = (spreadAdj[cur] || [])
      .filter(n => act[n.target] && !visited.has(n.target))
      .sort((a, b) => (act[b.target] || 0) - (act[a.target] || 0));
    for (const n of nb) {
      if (visited.has(n.target)) continue;
      visited.add(n.target);
      depthMap[n.target] = depthMap[cur] + 1;
      parentMap[n.target] = cur;
      bfsQueue.push(n.target);
    }
  }

  // Dim only nodes/links not previously lit by spread
  nodes.forEach(n => {
    if (!n.__sphere) return;
    if (litNodes.has(n.id)) return; // already lit, keep bright
    n.__sphere.material.opacity = 0.15;
    n.__sphere.material.emissiveIntensity = 0.08;
    if (n.__label) n.__label.material.opacity = 0.1;
  });
  const gData = Graph.graphData();
  gData.links.forEach((link, i) => { 
    if (litLinks.has(i)) return; // already lit
    if (link.__lineObj) link.__lineObj.material.opacity = 0.05; 
  });

  // Light up seed node with glow-in animation
  litNodes.add(node.id);
  if (node.__sphere) {
    const s = node.__sphere, lbl = node.__label;
    const s0 = s.material.opacity, e0 = s.material.emissiveIntensity, l0 = lbl ? lbl.material.opacity : 0;
    const t0 = performance.now();
    (function anim() {
      const p = Math.min((performance.now() - t0) / 250, 1), ease = p * (2 - p);
      s.material.opacity = s0 + (1.0 - s0) * ease;
      s.material.emissiveIntensity = e0 + (1.0 - e0) * ease;
      if (lbl) lbl.material.opacity = l0 + (1.0 - l0) * ease;
      if (p < 1) requestAnimationFrame(anim);
    })();
  }

  const scene = Graph.scene();
  const actSet = new Set(Object.keys(act));
  const hopDelayMs = 400; // time between hops
  const pulseTravelMs = 350; // how long a pulse takes to travel one edge

  // For each activated node (except seed), schedule an electric current along the edge
  Object.entries(depthMap).forEach(([nid, hop]) => {
    if (hop === 0) return; // seed already lit
    const parentId = parentMap[nid];
    if (!parentId) return;
    const energy = (act[nid] || 0) / maxAct;

    const startDelay = hop * hopDelayMs;

    const tid = setTimeout(() => {
      const srcNode = nodes.find(x => x.id === parentId);
      const tgtNode = nodes.find(x => x.id === nid);
      if (!srcNode || !tgtNode || srcNode.x === undefined || tgtNode.x === undefined) return;

      // Find the link
      const link = gData.links.find(l => {
        const sid = typeof l.source === 'object' ? l.source.id : l.source;
        const tid2 = typeof l.target === 'object' ? l.target.id : l.target;
        return (sid === parentId && tid2 === nid) || (sid === nid && tid2 === parentId);
      });

      // Don't light source node here ‚Äî it should already be lit from previous hop
      // Target node will be lit when current arrives

      // Create electric current overlay line ‚Äî use same path as library line
      const color = new THREE.Color(getColor(parentId)).lerp(new THREE.Color(getColor(nid)), 0.5);
      const glowColor = color.clone().multiplyScalar(2.0);

      let segments, positions;

      // Try to copy path from the actual library line
      if (link && link.__lineObj) {
        const srcPos = link.__lineObj.geometry.getAttribute('position');
        if (srcPos && srcPos.count >= 2) {
          const count = srcPos.count;
          segments = count - 1;
          // Check direction: overlay should go parent‚Üítarget
          const srcId = typeof link.source === 'object' ? link.source.id : link.source;
          const reverse = srcId !== parentId;
          positions = new Float32Array(count * 3);
          for (let i = 0; i < count; i++) {
            const idx = reverse ? (count - 1 - i) : i;
            positions[i*3]   = srcPos.getX(idx);
            positions[i*3+1] = srcPos.getY(idx);
            positions[i*3+2] = srcPos.getZ(idx);
          }
        }
      }

      // Fallback: compute our own bezier
      if (!positions) {
        segments = 30;
        positions = new Float32Array((segments + 1) * 3);
        const mx = (srcNode.x + tgtNode.x) / 2;
        const my = (srcNode.y + tgtNode.y) / 2;
        const mz = (srcNode.z + tgtNode.z) / 2;
        const dx = tgtNode.x - srcNode.x, dy = tgtNode.y - srcNode.y, dz = tgtNode.z - srcNode.z;
        const len = Math.sqrt(dx*dx + dy*dy + dz*dz) || 1;
        const curvature = Math.min(len * 0.15, 20);
        let px = -dz, pz = dx;
        const plen = Math.sqrt(px*px + pz*pz) || 1;
        px = px/plen * curvature; pz = pz/plen * curvature;
        const cpx = mx + px, cpy = my, cpz = mz + pz;
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const t1 = 1 - t;
          positions[i*3]   = t1*t1*srcNode.x + 2*t1*t*cpx + t*t*tgtNode.x;
          positions[i*3+1] = t1*t1*srcNode.y + 2*t1*t*cpy + t*t*tgtNode.y;
          positions[i*3+2] = t1*t1*srcNode.z + 2*t1*t*cpz + t*t*tgtNode.z;
        }
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      // Start with 0 vertices drawn ‚Äî will animate drawRange
      geo.setDrawRange(0, 0);

      const mat = new THREE.LineBasicMaterial({
        color: glowColor, transparent: true, opacity: 1.0,
        depthWrite: false, linewidth: 2
      });
      const currentLine = new THREE.Line(geo, mat);
      // Spread current should always bloom
      markBloom(currentLine, true);
      scene.add(currentLine);

      pulseParticles.push({
        currentLine,
        segments,
        startTime: performance.now(),
        duration: pulseTravelMs,
        energy,
        targetNodeId: nid,
        targetNode: tgtNode,
        sourceNode: srcNode,
        link,
        done: false
      });

      if (!pulseAnimRunning) {
        pulseAnimRunning = true;
        requestAnimationFrame(animatePulses);
      }
    }, startDelay);
    spreadTimeouts.push(tid);
  });

  // No fallback ‚Äî the electric current animation IS the spread result
}

function animatePulses(now) {
  let anyActive = false;
  pulseParticles.forEach(p => {
    if (p.done) return;
    const elapsed = now - p.startTime;
    const t = Math.min(elapsed / p.duration, 1);

    // Animate drawRange ‚Äî electric current extends from source to target
    const vertexCount = Math.floor(t * (p.segments + 1));
    p.currentLine.geometry.setDrawRange(0, vertexCount);

    // Fade the glow line slightly as it completes
    p.currentLine.material.opacity = 0.6 + 0.4 * Math.sin(t * Math.PI);

    // DON'T light the underlying edge during animation ‚Äî
    // the overlay currentLine IS the visual. Only light the edge when current arrives.

    if (t >= 1) {
      // Current reached target ‚Äî crossfade: overlay fades out while underlying edge fades in
      p.done = true;
      
      // Light endpoints immediately (they animate via lightNode)
      if (p.targetNode) lightNode(p.targetNode.id);
      if (p.sourceNode) lightNode(p.sourceNode.id);
      
      // Find the link (retry if needed)
      const theLink = p.link || (() => {
        const gData = Graph.graphData();
        return gData.links.find(l => {
          const sid = typeof l.source === 'object' ? l.source.id : l.source;
          const tid2 = typeof l.target === 'object' ? l.target.id : l.target;
          return (sid === p.sourceNode?.id && tid2 === p.targetNode?.id) || 
                 (sid === p.targetNode?.id && tid2 === p.sourceNode?.id);
        });
      })();
      
      // Mark as lit
      if (theLink) {
        const gData = Graph.graphData();
        const li = gData.links.indexOf(theLink);
        if (li >= 0) litLinks.add(li);
      }
      
      // Crossfade over 300ms: overlay out, underlying in
      const fadeStart = performance.now();
      const fadeDur = 300;
      const underlyingObj = theLink && theLink.__lineObj;
      const underStart = underlyingObj ? underlyingObj.material.opacity : 0;
      
      const crossfade = () => {
        const ft = Math.min((performance.now() - fadeStart) / fadeDur, 1);
        const ease = ft * (2 - ft);
        // Overlay fades out
        p.currentLine.material.opacity = 1.0 - ft;
        // Underlying fades in
        if (underlyingObj) {
          underlyingObj.material.opacity = underStart + (1.0 - underStart) * ease;
        }
        if (ft < 1) {
          requestAnimationFrame(crossfade);
        } else {
          Graph.scene().remove(p.currentLine);
          p.currentLine.geometry.dispose();
          p.currentLine.material.dispose();
          // Ensure final state
          if (underlyingObj) underlyingObj.material.opacity = 1.0;
        }
      };
      requestAnimationFrame(crossfade);
    } else {
      anyActive = true;
    }
  });

  if (anyActive || pulseParticles.some(p => !p.done)) {
    requestAnimationFrame(animatePulses);
  } else {
    pulseAnimRunning = false;
  }
}

function restoreAll(instant) {
  resetSpread();
  litNodes.clear();
  litLinks.clear();
  const gData = Graph.graphData();
  if (instant) {
    nodes.forEach(n => {
      if (!n.__sphere) return;
      n.__sphere.material.opacity = 0.85;
      n.__sphere.material.emissiveIntensity = 0.3;
      if (n.__label) n.__label.material.opacity = 0.85;
    });
    gData.links.forEach(link => { if (link.__lineObj) link.__lineObj.material.opacity = 0.4; });
  } else {
    const nSnaps = [];
    nodes.forEach(n => {
      if (!n.__sphere) return;
      nSnaps.push({ s: n.__sphere, lbl: n.__label, o0: n.__sphere.material.opacity, e0: n.__sphere.material.emissiveIntensity, l0: n.__label ? n.__label.material.opacity : 0 });
    });
    const lSnaps = [];
    gData.links.forEach(link => {
      if (link.__lineObj) lSnaps.push({ obj: link.__lineObj, o0: link.__lineObj.material.opacity });
    });
    const t0 = performance.now();
    (function anim() {
      const p = Math.min((performance.now() - t0) / 350, 1), ease = p * (2 - p);
      nSnaps.forEach(d => {
        d.s.material.opacity = d.o0 + (0.85 - d.o0) * ease;
        d.s.material.emissiveIntensity = d.e0 + (0.3 - d.e0) * ease;
        if (d.lbl) d.lbl.material.opacity = d.l0 + (0.85 - d.l0) * ease;
      });
      lSnaps.forEach(d => {
        d.obj.material.opacity = d.o0 + (0.4 - d.o0) * ease;
      });
      if (p < 1) requestAnimationFrame(anim);
    })();
  }
  clickedNode = null;
  document.getElementById('tooltip').style.display = 'none';
}

function lightNode(nid) {
  if (litNodes.has(nid)) return;
  litNodes.add(nid);
  const n = nodes.find(x => x.id === nid);
  if (n && n.__sphere) {
    const s = n.__sphere, lbl = n.__label;
    const s0 = s.material.opacity, e0 = s.material.emissiveIntensity, l0 = lbl ? lbl.material.opacity : 0;
    const t0 = performance.now();
    (function anim() {
      const p = Math.min((performance.now() - t0) / 200, 1), ease = p * (2 - p);
      s.material.opacity = s0 + (1.0 - s0) * ease;
      s.material.emissiveIntensity = e0 + (0.6 - e0) * ease;
      if (lbl) lbl.material.opacity = l0 + (1.0 - l0) * ease;
      if (p < 1) requestAnimationFrame(anim);
    })();
  }
}

function lightLink(link) {
  if (!link || !link.__lineObj) return;
  const gData = Graph.graphData();
  const li = gData.links.indexOf(link);
  if (li >= 0) litLinks.add(li);
  // Animate line opacity
  const obj = link.__lineObj;
  const s0 = obj.material.opacity;
  const t0 = performance.now();
  (function anim() {
    const p = Math.min((performance.now() - t0) / 200, 1), ease = p * (2 - p);
    obj.material.opacity = s0 + (1.0 - s0) * ease;
    if (p < 1) requestAnimationFrame(anim);
  })();
  // Always light both endpoints
  const sid = typeof link.source === 'object' ? link.source.id : link.source;
  const tid = typeof link.target === 'object' ? link.target.id : link.target;
  lightNode(sid);
  lightNode(tid);
}

function resetSpread() {
  spreadTimeouts.forEach(t => clearTimeout(t));
  spreadTimeouts = [];
  // Clean up pulse particles
  pulseParticles.forEach(p => {
    if (p.currentLine && !p.done) {
      Graph.scene().remove(p.currentLine);
      p.currentLine.geometry.dispose();
      p.currentLine.material.dispose();
    }
  });
  pulseParticles.length = 0;
  pulseAnimRunning = false;
  spreadActive = false;
  clickedNode = null;
  // Don't restore opacity ‚Äî keep activated nodes/links lit
}

// === TOOLTIP ===
function showTooltip(node) {
  if (!node) return;
  const tooltip = document.getElementById('tooltip');
  const color = getColor(node.id);
  let html = '<div class="tt-name" style="color:' + color + '">' + node.id + '</div>';
  html += '<div class="tt-type">' + (node.type || '') + (nodeCluster[node.id] ? ' ¬∑ ' + clusterLabels[nodeCluster[node.id]] : '') + '</div>';
  html += '<div class="tt-meta">ËøûÊé•Êï∞: ' + (degree[node.id] || 0) + '</div>';
  if (node.aliases && node.aliases.length) html += '<div class="tt-meta">Âà´Âêç: ' + node.aliases.slice(0,5).join(' ¬∑ ') + '</div>';
  if (node.definition) html += '<div class="tt-meta">' + node.definition + '</div>';
  if (node.status) html += '<div class="tt-meta">Áä∂ÊÄÅ: ' + node.status + '</div>';
  if (node.deploy) html += '<div class="tt-meta">üîó ' + node.deploy + '</div>';
  tooltip.innerHTML = html;
  tooltip.style.display = 'block';
  // Position near mouse (updated by mousemove)
  tooltip.style.left = (_mouseX + 16) + 'px';
  tooltip.style.top = (_mouseY + 16) + 'px';
}

// Track mouse for link tooltip positioning
let _mouseX = 0, _mouseY = 0;
container.addEventListener('mousemove', e => {
  _mouseX = e.clientX; _mouseY = e.clientY;
  const lt = document.getElementById('link-tooltip');
  if (lt.style.display === 'block') {
    lt.style.left = (e.clientX + 14) + 'px';
    lt.style.top = (e.clientY - 10) + 'px';
  }
  const tooltip = document.getElementById('tooltip');
  if (tooltip.style.display === 'block') {
    tooltip.style.left = (e.clientX + 14) + 'px';
    tooltip.style.top = (e.clientY - 10) + 'px';
  }
});

// === SEARCH ===
const searchInput = document.getElementById('search');
let searchQuery = '';
searchInput.addEventListener('input', () => {
  searchQuery = searchInput.value.trim().toLowerCase();
  if (!searchQuery) {
    resetSpread();
    hoveredNode = null;
    updateHighlight();
    return;
  }
  const matched = new Set();
  nodes.forEach(n => { if (n.id.toLowerCase().includes(searchQuery)) matched.add(n.id); });

  nodes.forEach(node => {
    if (!node.__sphere) return;
    const mat = node.__sphere.material;
    const label = node.__label;
    if (matched.has(node.id)) {
      mat.opacity = 1.0;
      mat.emissiveIntensity = 0.8;
      if (label) label.material.opacity = 1.0;
    } else {
      mat.opacity = 0.06;
      mat.emissiveIntensity = 0.02;
      if (label) label.material.opacity = 0.04;
    }
  });
});

searchInput.addEventListener('keydown', e => e.stopPropagation());

// === LEGEND ===
const legendDiv = document.getElementById('legend');
const legendItems = graphData.clusters.map(c => [c.label, clusterColors[c.id] || '#888']);
legendItems.push(['Êó†ÈõÜÁæ§', '#dddddd']);
legendDiv.innerHTML = '<div class="legend-header">Âõæ‰æã</div><div class="legend-body">' + legendItems.map(([l, c]) =>
  '<div class="item"><div class="dot" style="background:' + c + ';box-shadow:0 0 6px ' + c + '"></div>' + l + '</div>'
).join('') + '</div>';
legendDiv.addEventListener('click', () => legendDiv.classList.toggle('open'));

// === STATS ===
document.getElementById('stats').textContent = nodes.length + ' nodes ¬∑ ' + links.length + ' edges';


// === CLUSTER AURAS (soft glow sprites at cluster centers) ===
const clusterAuras = {};
function createGlowTexture(size) {
  const canvas = document.createElement('canvas');
  canvas.width = size; canvas.height = size;
  const ctx = canvas.getContext('2d');
  const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
  gradient.addColorStop(0, 'rgba(255,255,255,0.3)');
  gradient.addColorStop(0.3, 'rgba(255,255,255,0.08)');
  gradient.addColorStop(0.7, 'rgba(255,255,255,0.02)');
  gradient.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, size, size);
  return new THREE.CanvasTexture(canvas);
}
const glowTex = createGlowTexture(128);

function updateClusterAuras() {
  // Hide all auras in semantic mode
  if (semanticMode) {
    Object.values(clusterAuras).forEach(a => { a.visible = false; });
    return;
  }
  Object.entries(clusterNodeMap).forEach(([cid, nids]) => {
    const pts = nids.map(nid => {
      const n = nodes.find(x => x.id === nid);
      return n && n.x !== undefined ? n : null;
    }).filter(Boolean);
    if (pts.length < 2) {
      if (clusterAuras[cid]) clusterAuras[cid].visible = false;
      return;
    }
    // Compute centroid and spread
    let cx = 0, cy = 0, cz = 0;
    pts.forEach(p => { cx += p.x; cy += p.y; cz += p.z; });
    cx /= pts.length; cy /= pts.length; cz /= pts.length;
    let maxDist = 0;
    pts.forEach(p => {
      const d = Math.sqrt((p.x-cx)**2 + (p.y-cy)**2 + (p.z-cz)**2);
      if (d > maxDist) maxDist = d;
    });
    const auraSize = Math.max(maxDist * 2.5 + 30, 40);

    const color = clusterColors[cid] || '#666';
    if (clusterAuras[cid]) {
      clusterAuras[cid].position.set(cx, cy, cz);
      clusterAuras[cid].scale.set(auraSize, auraSize, 1);
      clusterAuras[cid].visible = true;
    } else {
      const mat = new THREE.SpriteMaterial({
        map: glowTex, color: new THREE.Color(color),
        transparent: true, opacity: 0.35,
        depthWrite: false, blending: THREE.AdditiveBlending
      });
      const sprite = new THREE.Sprite(mat);
      sprite.position.set(cx, cy, cz);
      sprite.scale.set(auraSize, auraSize, 1);
      sprite.renderOrder = -1;
      Graph.scene().add(sprite);
      clusterAuras[cid] = sprite;
    }
  });
}

let auraInterval = setInterval(() => {
  if (nodes[0] && nodes[0].x !== undefined) updateClusterAuras();
}, 500);
setTimeout(() => {
  updateClusterAuras();
  clearInterval(auraInterval);
  setInterval(updateClusterAuras, 1000);
}, 6000);

// === INITIAL CAMERA ===
// Start inside the graph, not far away
Graph.cameraPosition({ x: 0, y: 150, z: 600 });
// No zoomToFit ‚Äî we stay inside the graph like a game

// === LIGHTING + BLOOM (selective) ===
const BLOOM_LAYER = 1;
const bloomLayer = new THREE.Layers();
bloomLayer.set(BLOOM_LAYER);
const darkMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
const materials = {};

function markBloom(obj, enable) {
  if (!obj) return;
  if (enable) obj.layers.enable(BLOOM_LAYER);
  else obj.layers.disable(BLOOM_LAYER);
}

setTimeout(() => {
  const scene = Graph.scene();
  scene.add(new THREE.AmbientLight(0x444466, 1.5));
  const pl1 = new THREE.PointLight(0x6666ff, 1.2, 650);
  pl1.position.set(100, 100, 100);
  scene.add(pl1);
  const pl2 = new THREE.PointLight(0xff6644, 0.8, 650);
  pl2.position.set(-100, -50, -100);
  scene.add(pl2);

  // Mark today's active nodes + active links for bloom
  nodes.forEach(n => {
    if (n.__sphere) markBloom(n.__sphere, !!n.__active);
  });
  links.forEach(l => {
    const srcId = typeof l.source === 'object' ? l.source.id : l.source;
    const tgtId = typeof l.target === 'object' ? l.target.id : l.target;
    const key = srcId + '‚Üí' + tgtId;
    const keyR = tgtId + '‚Üí' + srcId;
    if (_activeEdges3d.has(key) || _activeEdges3d.has(keyR)) {
      if (l.__lineObj) markBloom(l.__lineObj, true);
    }
  });

  /* --- Postprocessing disabled: CDN scripts 404, emissive glow works without bloom ---
  const renderer = Graph.renderer();
  const camera = Graph.camera();

  const renderPass = new THREE.RenderPass(scene, camera);
  const bloomPass = new THREE.UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    3.5,
    0.9,
    0.05
  );

  const bloomComposer = new THREE.EffectComposer(renderer);
  bloomComposer.renderToScreen = false;
  bloomComposer.addPass(renderPass);
  bloomComposer.addPass(bloomPass);

  const finalComposer = new THREE.EffectComposer(renderer);
  finalComposer.addPass(renderPass);

  // Add bloom result on top (additive) via a fullscreen quad
  const bloomStrength = 2.2; // extra boost on top of UnrealBloomPass
  const mixPass = new THREE.ShaderPass({
    uniforms: {
      baseTexture: { value: null },
      bloomTexture: { value: bloomComposer.renderTarget2.texture },
      strength: { value: bloomStrength }
    },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D baseTexture;
      uniform sampler2D bloomTexture;
      uniform float strength;
      varying vec2 vUv;
      void main() {
        vec4 base = texture2D(baseTexture, vUv);
        vec4 bloom = texture2D(bloomTexture, vUv);
        gl_FragColor = base + bloom * strength;
      }
    `
  }, 'baseTexture');
  finalComposer.addPass(mixPass);

  // FXAA for the final output (helps bloom edges)
  const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
  fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * renderer.getPixelRatio());
  fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * renderer.getPixelRatio());
  finalComposer.addPass(fxaaPass);

  // Override render loop to do selective bloom + final compose
  Graph.postProcessingComposer(null);

  function darkenNonBloom(obj) {
    // Darken everything not in bloom layer.
    // Handle BOTH Mesh and Line (current is a Line).
    if ((obj.isMesh || obj.isLine) && bloomLayer.test(obj.layers) === false) {
      materials[obj.uuid] = obj.material;
      obj.material = darkMaterial;
    }
  }
  function restoreMaterial(obj) {
    if (materials[obj.uuid]) {
      obj.material = materials[obj.uuid];
      delete materials[obj.uuid];
    }
  }

  const oldAnimate = animate;
  animate = function(time) {
    requestAnimationFrame(animate);
    oldAnimate(time);

    // Render bloom only
    camera.layers.set(BLOOM_LAYER);
    scene.traverse(darkenNonBloom);
    bloomComposer.render();
    scene.traverse(restoreMaterial);

    // Render full scene
    camera.layers.set(0);
    finalComposer.render();
  };
  --- end postprocessing disabled */
}, 120);

// === PARTICLE FLOW (strong links w >= 5) ===
const particleMeshes = [];
setTimeout(() => {
  const scene = Graph.scene();
  links.forEach(link => {
    if ((link.weight || 0) < 5) return;
    const count = Math.min(Math.floor(link.weight / 3), 3);
    for (let i = 0; i < count; i++) {
      const srcId = typeof link.source === 'object' ? link.source.id : link.source;
      const color = new THREE.Color(getColor(srcId));
      const geo = new THREE.SphereGeometry(0.3, 8, 6);
      const mat = new THREE.MeshBasicMaterial({
        color, transparent: true, opacity: 0, depthWrite: false
      });
      const mesh = new THREE.Mesh(geo, mat);
      scene.add(mesh);
      particleMeshes.push({
        mesh, link, t: Math.random(), speed: 0.001 + Math.random() * 0.002, color
      });
    }
  });
}, 200);

// === ANIMATION LOOP (breathing + particles) ===
function animate(time) {
  requestAnimationFrame(animate);
  const t = time * 0.001;

  // Glow animation ‚Äî active nodes + active links pulse like electric current
  if (!spreadActive) {
    const pulse = Math.sin(t * 2) * 0.5 + 0.5;

    // Active nodes ‚Äî skip when hover/spread is controlling
    if (!hoveredNode && !spreadActive) {
      nodes.forEach(node => {
        if (!node.__sphere) return;
        if (node.__active) {
          node.__sphere.material.emissiveIntensity = 0.3 + pulse * 1.2;
          node.__sphere.material.opacity = 0.6 + pulse * 0.4;
          const s = 1 + pulse * 0.06;
          node.__sphere.scale.set(s, s, s);
        }
      });
    }

    // Active links (today) ‚Äî skip when hover/spread is controlling opacity
    if (!hoveredNode && !spreadActive) {
      links.forEach(link => {
        const srcId = typeof link.source === 'object' ? link.source.id : link.source;
        const tgtId = typeof link.target === 'object' ? link.target.id : link.target;
        const key = srcId + '‚Üí' + tgtId;
        const keyR = tgtId + '‚Üí' + srcId;
        const active = _activeEdges3d.has(key) || _activeEdges3d.has(keyR);
        if (!link.__customMat) return;
        const w = link.weight || 1;
        const base = 0.1 + Math.min(w / 8, 1) * 0.7;
        link.__customMat.opacity = active ? Math.min(1, 0.35 + pulse * 0.65) : base;
      });
    }
  }

  // Particle flow along strong edges
  particleMeshes.forEach(p => {
    p.t += p.speed;
    if (p.t > 1) p.t -= 1;

    const src = typeof p.link.source === 'object' ? p.link.source : null;
    const tgt = typeof p.link.target === 'object' ? p.link.target : null;
    if (!src || !tgt || src.x === undefined || tgt.x === undefined) {
      p.mesh.visible = false;
      return;
    }

    // Lerp position along edge
    const x = src.x + (tgt.x - src.x) * p.t;
    const y = src.y + (tgt.y - src.y) * p.t;
    const z = src.z + (tgt.z - src.z) * p.t;
    p.mesh.position.set(x, y, z);

    // Fade in/out near endpoints
    const fade = Math.min(p.t, 1 - p.t) * 4;
    p.mesh.material.opacity = Math.min(fade, 0.7);
    p.mesh.visible = true;
  });
}
requestAnimationFrame(animate);

// === KEYBOARD CONTROLS (WASD game-style) ===
const keysDown = new Set();
let isDragging = false;
window.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT') return;
  if (e.code === 'Escape') { restoreAll(); return; }
  keysDown.add(e.code);
});
window.addEventListener('keyup', e => keysDown.delete(e.code));
// Track mouse drag state to avoid WASD+drag conflict
window.addEventListener('mousedown', () => { isDragging = true; });
window.addEventListener('mouseup', () => { isDragging = false; });

// Block OrbitControls dolly
setTimeout(() => {
  const controls = Graph.controls();
  if (controls) {
    controls.enableZoom = false;
    controls.enablePan = false;
  }
  // Bind our wheel handler on canvas capture phase, before OrbitControls
  const canvas = document.querySelector('#graph-container canvas');
  if (canvas) {
    canvas.addEventListener('wheel', handleWheel, { capture: true, passive: false });
  }
}, 200);

function handleWheel(e) {
  if (e.target.tagName === 'INPUT') return;
  e.preventDefault();
  e.stopPropagation();
  const cam = Graph.camera();
  const controls = Graph.controls();
  cam.updateMatrixWorld();
  const m = cam.matrixWorld.elements;
  const camRight = new THREE.Vector3(m[0], m[1], m[2]).normalize();
  const camForward = new THREE.Vector3(-m[8], -m[9], -m[10]).normalize();
  const camUp = new THREE.Vector3(m[4], m[5], m[6]).normalize();

  if (e.ctrlKey) {
    // Pinch = forward/back
    const speed = e.deltaY < 0 ? 6 : -6;
    cam.position.addScaledVector(camForward, speed);
    controls.target.addScaledVector(camForward, speed);
  } else {
    // Two-finger drag = left/right + up/down (same as WASD)
    const speedX = -e.deltaX * 0.15;
    const speedY = e.deltaY * 0.15;
    const move = new THREE.Vector3();
    move.addScaledVector(camRight, speedX);
    move.addScaledVector(camUp, speedY);
    cam.position.add(move);
    controls.target.add(move);
  }
  controls.update();
}

function tickKeyboard() {
  requestAnimationFrame(tickKeyboard);
  if (keysDown.size === 0 || isDragging) return; // pause WASD during drag
  const cam = Graph.camera();
  const controls = Graph.controls();
  const speed = 3;

  // Extract camera's local axes from its world matrix
  // This always matches what the user sees on screen
  cam.updateMatrixWorld();
  const m = cam.matrixWorld.elements;
  // Camera's local right (first column)
  const camRight = new THREE.Vector3(m[0], m[1], m[2]).normalize();
  // Camera's local up (second column)
  const camUp = new THREE.Vector3(m[4], m[5], m[6]).normalize();
  // Camera's local forward (negative third column ‚Äî camera looks down -Z)
  const camForward = new THREE.Vector3(-m[8], -m[9], -m[10]).normalize();

  let move = new THREE.Vector3();
  if (keysDown.has('KeyW')) move.addScaledVector(camUp, speed);
  if (keysDown.has('KeyS')) move.addScaledVector(camUp, -speed);
  if (keysDown.has('KeyA')) move.addScaledVector(camRight, -speed);
  if (keysDown.has('KeyD')) move.addScaledVector(camRight, speed);
  if (keysDown.has('KeyQ')) move.addScaledVector(camForward, speed);
  if (keysDown.has('KeyE')) move.addScaledVector(camForward, -speed);

  if (move.lengthSq() > 0) {
    cam.position.add(move);
    controls.target.add(move);
  }
  controls.update();
}
requestAnimationFrame(tickKeyboard);

// === CHANGELOG ===
if (typeof graphChangelog !== 'undefined' && graphChangelog.length) {
  const el = document.getElementById('changelog');
  let body = '';
  graphChangelog.slice().reverse().forEach(e => {
    const t = new Date(e.ts);
    const time = `${t.getMonth()+1}/${t.getDate()} ${String(t.getHours()).padStart(2,'0')}:${String(t.getMinutes()).padStart(2,'0')}`;
    let parts = [];
    if (e.nodes?.length) parts.push(e.nodes.map(n => `<span class="cl-node">+${n}</span>`).join(' '));
    if (e.edges?.length) parts.push(e.edges.map(x => `<span class="cl-edge">${x}</span>`).join(' '));
    if (e.weights?.length) parts.push(e.weights.map(w => `<span class="cl-weight">${w.edge} ${w.from.toFixed(2)}‚Üí${w.to.toFixed(2)}</span>`).join(' '));
    if (parts.length) body += `<div class="cl-entry"><span class="cl-time">${time}</span> ${parts.join(' ')}</div>`;
  });
  if (body) {
    el.innerHTML = `<div class="cl-header">ÂèòÂåñËÆ∞ÂΩï</div><div class="cl-body">${body}</div>`;
    el.style.display = 'block';
    el.querySelector('.cl-header').addEventListener('click', () => el.classList.toggle('open'));
  }
}

// === WINDOW RESIZE ===
window.addEventListener('resize', () => {
  Graph.width(window.innerWidth).height(window.innerHeight);
});

</script>
</body>
</html>
